.Dd September 4, 2023
.Dt SIMP 1
.Os
.Sh NAME
.Nm simp
.Nd simplistic programming language
.Sh SYNOPSIS
.Nm simp
.Nm simp
.Op Fl i
.Fl e Ar string
.Op Ar arg ...
.Nm simp
.Op Fl i
.Fl p Ar string
.Op Ar arg ...
.Nm simp
.Op Fl i
.Ar file
.Op Ar arg ...
.Sh DESCRIPTION
The
.Nm
utility is an interpreter for
.Em Simp ,
a minimalist (yet expressive),
statically scoped,
dynamically typed,
properly tail-recursive,
general-purpose LISP-1 programming language
in which imperative, funcional and message-passing programming styles
(to name a few) may be conveniently expressed.
It reads expressions from a file, string, or standard input, and evaluates them
(possibly writing to standard output the result of the evaluation, if in the REPL mode).
.Pp
The options are as follows:
.Bl -tag -width Ds
.It Fl e Ar string
Read expressions from
.Ar string
but do not write the resulting evaluation into standard output.
.It Fl i
Enter the interactive REPL mode after evaluating expressions from a string or file.
This flag is set by default if no argument is given.
.It Fl p Ar string
Read expressions from
.Ar string
and write the resulting evaluation into standard output.
.El
.Pp
In the first synopsis form, expressions are interpreted interactively in a REPL (read-eval-print loop).
Expressions are read from standard input (usually a terminal) and written to standard output.
.Pp
In the second synopsis form (with
.Fl e ) ,
expressions are read from
.Ar string
and the resulting evaluation is not written into standard output.
Unless the flag
.Fl i
is given, no interactive REPL occurs after evaluating the string.
.Pp
In the third synopsis form (with
.Fl p ) ,
expressions are read from
.Ar string
and the resulting evaluation is written into standard output.
Unless the flag
.Fl i
is given, no interactive REPL occurs after evaluating the string.
.Pp
In the fourth synopsis form (with an argument and neither
.Fl e
or
.Fl i ) ,
expressions are read from
.Ar file
and evaluated without outputing the result.
If
.Ar file
is an hyphen
.Pq "-" ,
read expressions from the standard input instead.
Unless the flag
.Fl i
is given, no interactive REPL occurs after evaluating the file.
.Pp
.Nm
(like most dialects of Lisp)
employs a fully parenthesized prefix notation for programs and other data known as
.Em S-expression
(or
.Dq sexp
for short).
However,
.Nm
implements S-expressions as
.Sy vectors
rather than cons cells (aka pairs).
In fact, it is the vector, not the pair, the primary mean
of data combination.
.Nm
has no notion of
.Ic cons , car , cdr
or other procedures common in other LISP dialects.
In
.Nm ,
lists can be implemented as a chain of vectors,
in which the last element of each vector is a pointer to the next vector.
.Sh EXPRESSIONS
A
.Nm
program is a sequence of expressions, possibly alternated with comments and whitespace.
The kind of value that an expression returns is specified below after the
.Em "⇒" symbol.
An expression can be a special form, a symbol, a literal or a procedure combination.
Builtin procedures are listed below, after the special forms.
.Ss Syntax Sugars
.Bl -tag -width Ds -compact
.It Ar "\eOBJECT" "⇒" OBJECT
Any object prefixed with a backslash is equivalent to quoting the object.
For example,
.Ic "\e()"
is expanded to the special form
.Ic "(quote ())"
while parsing.
.El
.Ss Non-vector Forms
.Bl -tag -width Ds -compact
.It Ar SYMBOL "⇒" OBJECT
Return the value that the given symbol is bound to in the current environment.
.Ar SYMBOL
must be a symbol already bound in the current environment;
otherwise an error is signaled.
.It Ar LITERAL "⇒" OBJECT
Return the given literal expression.
.Ar LITERAL
can be any expression, except a symbol or a vector.
.El
.Ss Special Forms
.Bl -tag -width Ds -compact
.It Ic ( and Ar EXPRESSION ... ) "⇒" OBJECT
Evaluate each expression in turn and return false when one evaluate to false;
return a true value otherwise.
.It Ic ( apply Ar PROCEDURE OBJECT ... ) "⇒" OBJECT
Return the result of the application of the given
procedure to all the given arguments.
.Ar PROCEDURE
must be an expression that evaluates to a procedure;
otherwise an error is signaled.
Each
.Ar ARGUMENT
must be an expression that evaluates to a single value;
otherwise an error is signaled.
As a syntax-sugar, the syntactical symbol
.Cm apply
can be replaced with the exclamation point.
.Cm "\)!" .
.It Ic ( define Ar SYMBOL EXPRESSION Ic ) "⇒" VOID
Bind the given symbol to the given expression in the current environment.
.Ar SYMBOL
must be a symbol;
otherwise an error is signaled.
.It Ic ( do Ar EXPRESSION ... Ic ) "⇒" OBJECT
Evaluate each given expression and return the result of the last evaluation.
.It Ic ( eval Ar EXPRESSION ENVIRONMENT ) "⇒" OBJECT
Evaluate the give expression in the given environment and return the result of the evaluation.
.Ar ENVIRONMENT
must be evaluate to an environment;
otherwise an error is signaled.
.It Ic ( false )
Return the false boolean constant.
.It Ic ( if Ar CONDITION ... THEN ... Op Ar ELSE ) "⇒" OBJECT
Evaluate each
.Ar CONDITION
expression in turn and, if it returns a true value, return the immediatelly following
.Ar THEN
expression.
If all condition-then pairs have been tested, return the optional
.Ar ELSE
condition, if it exists.
.It Ic ( lambda Ar VECTOR EXPRESSION ) "⇒" VOID
Return the closure in which the symbols in the given vector are bound to the actual arguments in the given body expression.
.It Ic ( lambda Ar SYMBOL EXPRESSION ) "⇒" VOID
Return the closure in which the given symbol is bound to the vector of actual arguments in the given body expression.
This special form is used for variadic procedures.
.It Ic ( or Ar EXPRESSION ... ) "⇒" OBJECT
Evaluate each expression in turn and return true when one evaluate to true;
return a false value otherwise.
.It Ic ( quote Ar EXPRESSION ) "⇒" OBJECT
Return the given expression itself, without evaluating it.
.It Ic ( set!\) Ar SYMBOL OBJECT ) "⇒" VOID
Rebound the given symbol to the given object in the current environment.
It is an error if the symbol is not already bound in the current environment.
.It Ic ( true ) Ar "⇒" TRUE
Return the true boolean constant.
.It Ar SYMBOL
Return the value that the given symbol is bound to in the current environment.
.Ar SYMBOL
must be a symbol already bound in the current environment;
otherwise an error is signaled.
.It Ar LITERAL
Return the given literal expression.
.Ar LITERAL
can be any expression, except a symbol or a vector.
.El
.Ss Type Procedures
.Bl -tag -width Ds -compact
.It Ic ( same?\) Ar OBJECT ... ) "⇒" BOOLEAN
Return whether the given objects are the same.
.It Ic ( boolean?\) Ar OBJECT ) "⇒" BOOLEAN
Return whether the given object is a boolean object.
.It Ic ( byte?\) Ar OBJECT ) "⇒" BOOLEAN
Return whether the given object is a byte object.
.It Ic ( empty?\) Ar OBJECT ) "⇒" BOOLEAN
Return whether the given object is the string object with zero elements.
.It Ic ( environment?\) Ar OBJECT ) "⇒" BOOLEAN
Return whether the given object is an environment object.
.It Ic ( false?\) Ar OBJECT ) "⇒" BOOLEAN
Return whether the given object is the false object.
.It Ic ( null?\) Ar OBJECT ) "⇒" BOOLEAN
Return whether the given object is the vector object with zero elements.
.It Ic ( port?\) Ar OBJECT ) "⇒" BOOLEAN
Return whether the given object is a port object.
.It Ic ( procedure?\) Ar OBJECT ) "⇒" BOOLEAN
Return whether the given object is a procedure object.
.It Ic ( string?\) Ar OBJECT ) "⇒" BOOLEAN
Return whether the given object is a string object.
.It Ic ( true?\) Ar OBJECT ) "⇒" BOOLEAN
Return whether the given object is not the false object.
.It Ic ( vector?\) Ar OBJECT ) "⇒" BOOLEAN
Return whether the given object is a vector object.
.El
.Ss Arithmetic Procedures
.Bl -tag -width Ds -compact
.It Ic ( "+" Ar NUMBER ... ) "⇒" NUMBER
Return the sum of the given numbers.
.It Ic ( "*" Ar NUMBER ... ) "⇒" NUMBER
Return the product of the given numbers.
.It Ic ( "-" Ar NUMBER NUMBER ... ) "⇒" NUMBER
Return the difference of the given numbers.
.It Ic ( "/" Ar NUMBER NUMBER ... ) "⇒" NUMBER
Return the ratio of the given numbers.
.It Ic ( "=" Ar NUMBER ... ) "⇒" BOOLEAN
Return whether the given numbers are equal.
.It Ic ( "<" Ar NUMBER ... ) "⇒" BOOLEAN
Return whether the given numbers are monotonically increasing.
.It Ic ( ">" Ar NUMBER ... ) "⇒" BOOLEAN
Return whether the given numbers are monotonically decreasing.
.It Ic ( "<=" Ar NUMBER ... ) "⇒" BOOLEAN
Return whether the given numbers are monotonically nondecreasing.
.It Ic ( ">=" Ar NUMBER ... ) "⇒" BOOLEAN
Return whether the given numbers are monotonically nonincreasing.
.El
.Ss String Procedures
.Bl -tag -width Ds -compact
.It Ic ( string Ar BYTE ... ) "⇒" STRING
Return a newly allocated string containing the given bytes.
.It Ic ( string-concat Ar STRING ... ) "⇒" STRING
Return a newly allocated string whose elements form the concatenation of the given strings.
.It Ic ( string-copy!\) Ar STRING STRING ) "⇒" VOID
Copy all elements of the second string into the first one.
The length of the second string must be lesser or equal to the first's, or an error will be signaled
.It Ic ( string-dup Ar STRING ) "⇒" STRING
Return a newly allocated string with size and elements the same as the given string.
.It Ic ( string-equiv?\) Ar STRING ... ) "⇒" BOOLEAN
Return whether the given strings have the same length and the same elements.
.It Ic ( string-length Ar STRING ) "⇒" NUMBER
Return the number of elements of the given string.
.It Ic ( string-new Ar NUMBER ) "⇒" STRING
Return a newly allocated string of the given size filled with the zero byte.
.It Ic ( string-ref Ar STRING NUMBER ) "⇒" BYTE
Return the i-th element of the given string.
.It Ic ( string-set!\) Ar STRING NUMBER BYTE ) "⇒" STRING
Set the i-th element of the given string to the given byte.
.It Ic ( substring Ar STRING [ NUMBER [ NUMBER ] ] ) "⇒" STRING
Return the given string indexed from the first given number (default 0)
with the second given number (default maximum possible) elements.
For example,
.Cm "(substring "abcde" 1 3)"
returns the string
.Cm "bcd" .
Both strings point to the same memory,
so changing an element in the resulting string
also changes the corresponding element in the original string.
.El
.Ss Vector Procedures
.Bl -tag -width Ds -compact
.It Ic ( subvector Ar VECTOR [ NUMBER [ NUMBER ] ] ) "⇒" VECTOR
Return the given vector indexed from the first given number (default 0)
with the second given number (default maximum possible) elements.
For example,
.Cm "(subvector (vector 'a' 'b' 'c' 'd' 'e') 1 3)"
returns the vector
.Cm "('b' 'c' 'd')" .
Both vectors point to the same memory,
so changing an element in the resulting vector
also changes the corresponding element in the original vector.
.It Ic ( string->vector Ar STRING ) "⇒" VECTOR
Return a newly allocated vector filled with the bytes of the given string.
.It Ic ( vector Ar OBJECT ... ) "⇒" VECTOR
Return a newly allocated vector containing the given objects.
.It Ic ( vector-concat Ar VECTOR ... ) "⇒" VECTOR
Return a newly allocated vector whose elements form the concatenation of the given vectors.
.It Ic ( vector-copy!\) Ar VECTOR VECTOR ) "⇒" VOID
Copy all elements of the second vector into the first one.
The length of the second vector must be lesser or equal to the first's.
.It Ic ( vector-dup Ar VECTOR ) "⇒" VECTOR
Return a newly allocated vector with size and elements the same as the given vector.
.It Ic ( vector-equiv?\) Ar VECTOR ... ) "⇒" BOOLEAN
Return whether the given vectors have the same length and the same elements.
.It Ic ( vector-length Ar VECTOR ) "⇒" NUMBER
Return the number of elements of the given vector.
.It Ic ( vector-new Ar NUMBER ) "⇒" VECTOR
Return a newly allocated vector of the given size filled with the null object.
.It Ic ( vector-ref Ar VECTOR NUMBER ) "⇒" OBJECT
Return the i-th element of the given vector.
.It Ic ( vector-set!\) Ar VECTOR NUMBER OBJECT ) "⇒" VECTOR
Set the i-th element of the given vector to the given object.
.El
.Ss Input/Output Procedures
.Bl -tag -width Ds -compact
.It Ic ( stderr ) Ar "⇒" PORT
Return the standard error port.
.It Ic ( stdin ) Ar "⇒" PORT
Return the standard input port.
.It Ic ( stdout ) Ar "⇒" PORT
Return the standard output port.
.It Ic ( display Ar OBJECT [ PORT ] ) "⇒" PORT
Write into the given object to the given port (standard output, by default)
in user-readable form.
.It Ic ( write Ar OBJECT [ PORT ] ) "⇒" PORT
Write into the given object to the given port (standard output, by default)
in its external representation.
.El
.Ss Environment Procedures
.Bl -tag -width Ds -compact
.It Ic ( environment-new Ar ENVIRONMENT ) "⇒" ENVIRONMENT
Return a newly allocated environment using the given environment as parent environment.
.It Ic ( environment-empty ) Ar "⇒" ENVIRONMENT
Return the empty environment.
.El
.Ss Lexicographical Comparison Procedures
.Bl -tag -width Ds -compact
.It Ic ( string-<?\) Ar STRING STRING ... ) "⇒" BOOLEAN
Return whether the given strings are lexicographically sorted in increasing order.
.It Ic ( string->?\) Ar STRING STRING ... ) "⇒" BOOLEAN
Return whether the given strings are lexicographically sorted in decreasing order.
.It Ic ( string-<=?\) Ar STRING STRING ... ) "⇒" BOOLEAN
Return whether the given strings are lexicographically sorted in nondecreasing order.
.It Ic ( string->=?\) Ar STRING STRING ... ) "⇒" BOOLEAN
Return whether the given strings are lexicographically sorted in nonincreasing order.
.El
.Sh EVALUATION
.Em Evaluation
is the process of computing values from expressions.
An expression can evaluate to zero or more values
(TODO: THAT'S A LIE, EACH EXPRESSION EVALUATES TO A SINGLE OBJECT FOR NOW.
IN THE FUTURE SIMP WILL SUPPORT RETURNING MULTIPLE VALUES).
An expression can even evaluate to itself (a so called
.Em self-evaluating
expression).
An evaluation can do more than just compute things,
such as mutate an object, or perform input/output;
such additional processes are called
.Em side effects .
An expression can also signal an error,
in which case, the evaluation algorithm is interrupted,
even when at a deep level of recursion.
.Pp
Although objects are usually read and then evaluated, those are separate processes, and either can be performed alone.
Reading does not evaluate anything; it just converts an external representation of an object to the object itself.
For example, the sequence of characters
.Qq Ic "(apply + 2 6)"
is an external representation of an object that evaluates to the integer 8;
it is not however an external representation of the integer 8.
The syntax of
.Nm
has the property that any sequence of characters that is an expression is also the external representation of some object.
That can lead to confusion, since it may not be obvious out of context whether a given sequence of characters is intended to denote data or program,
but it is also a source of power, since it facilitates writing programs such as interpreters and compilers that treat programs as data (or vice versa).
.Pp
This manual uses the rightwards double arrow symbol
.Dq Ic "⇒"
.Pq "U+21D2"
to separate the external representation of an object from the external representation of the objects it evaluates to.
For example
.Qq Ic "(apply + 2 6) ⇒ 8"
means that the object represented by
.Qq Ic "(apply + 2 6)"
evaluates to the object represented by
.Qq Ic "8" .
.Pp
This manual also uses the triple bar symbol
.Dq Ic "≡"
.Pq U+2261
to separate the external representations of two objects that evaluate to the same objects.
For example
.Qq Ic "(apply + 2 6) ≡ (apply + 4 4)"
means that the object represented by
.Qq Ic "(apply + 2 6)"
and the object represented by
.Qq Ic "(apply + 4 4)"
evaluate to the same thing.
.Pp
There are two means of comparing objects.
Two objects are the
.Em same
if they denote they are bound to the same thing or location.
Two objects are
.Em equivalent
if the values stored in their locations are the same.
.Pp
Evaluation is subject to the current environment (see below).
.Ss Environment
An identifier may name a location in memory where a value can be stored.
Such identifier is called a
.Em variable
and is said to be
.Em bound
to that location.
The set of all visible bindings in effect at some point in a program is known as the
.Em environment
in effect at that point.
The value stored in the location to which a variable is bound is called the variable's
.Em value .
By abuse of terminology, the variable is sometimes said to name the value or to be bound to the value.
This is not quite accurate, but confusion rarely results from this practice.
.Pp
An environment is a sequence of
.Em frames .
Each frame is a table (possible empty) of
.Em bindings ,
which associate variable names with their corresponding location in memory.
Frames are structured as a tree:
each frame can point to either nothing or to a parent tree.
The
.Em value of a variable
with respect to an environment
is the value on the location given by the binding of the variable
in the first frame in the environment that contains a binding for that variable.
If no frame in the sequence specifies a binding for the variable,
then the variable is said to be
.Em unbound
in the environment.
.Pp
The environment is crucial for the evaluation process,
because it determines the context in which an expression should be evaluated.
Indeed, one could say that expressions do not, in themselves, have any meaning.
Rather, an expression aquires a meaning only with respect to some environment in which it is evaluated.
Even the interpretation of an expression as straightforward as
.Ic "(apply + 1 1)"
depends on an understanding that one is operating in a context in which
.Ic "\)+"
is the symbol of addition.
.Pp
.Nm
is a statically scoped language with block structure.
To each place where an identifier is bound in a program there corresponds a
.Em region
of the program text within which the binding is visible.
Every mention of an identifier refers to the binding of the identifier that established the innermost of the regions containing the use.
If there is no binding of the identifier whose region contains the use, then the use refers to the binding for the variable in the top level environment, if any.
If there is no binding for the identifier, it is said to be
.Em unbound .
.Ss External representations
An important concept in
.Nm
(and Lisp)
is that of the
.Em external representation
of an object as a sequence of characters.
There are two forms of external representation:
the printed and the read forms.
.Pp
The
.Em printed external representation
of an object is unique;
and all objects have a printed external representation.
For example, the printed external representation of the integer 28 is the sequence of characters
.Qq Ic "28" ,
and the printed external representation of a vector consisting of the integers 8 and 13 is the sequence of characters
.Qq Ic "(8 13)" .
The printed external representation of an object is generated by the
.Ic write
procedure.
.Pp
The
.Em read external representation
of an object is not necessarily unique;
and certain objects may have no read external representation at all.
The integer 28 has the read external representations
.Qq Ic "28" ,
.Qq Ic "28e",
and
.Qq Ic "0x1C" ,
among others.
Closures and port objects, for example, have no read external representation.
The read external representation of an object is parsed by the
.Ic read
procedure.
.Pp
In most cases, an object's printed external representation is also a valid read external representation for the object.
Objects that have no read external representations have their printed external representation surrounded by
.Qq Ic "#<"
and
.Qq Ic ">" .
For example, the printed external representation of the an output port is something like
.Qq Ic "#<output-port 0x0123456789ABCDEF>".
.Sh DATA TYPES
A
.Em data type
can be interpreted as a set of possible objects.
Each object belong to at least one type.
Data types can overlap, and objects can belong to two or more types.
A
.Em primitive data type
is a basic data type that is built into
.Nm
and from which all other data types are constructed.
Primitive data types are
.Em disjoint
and do not overlap
(that is, each object belongs to one and only one primitive data type).
.Pp
.Nm
(like in most Lisps)
is a dynamically typed programming language.
Types are associated with objects
rather than with variables.
(Statically typed languages, by contrast, associate types with variables and expressions as well as with values).
Object are self-typing;
the primitive type of each object is implicit in the object itself.
.Pp
For each primitive data type (and a few other non-primitve ones),
the standard library defines a set of variables bound to objects
(constants, predicates, constructors, mutators, and accessors)
used to manipulate objects of that data type (see
.Sx STANDARD LIBRARY ) .
.Ss Numbers
[TODO: fixnums, bignums, numerical tower, etc]
.Ss Booleans
The boolean data type contains only two distinct unique objects: the true and false objects.
These objects have no read external representation, therefore they cannot be created by the
.Ic read
procedure.
They have, however, the printed external representations "#<true>" and "#<false>".
.Pp
Boolean objects (or "booleans" for short) can be used to control the evaluation of conditional procedures.
The procedures in the
.Sx STANDARD LIBRARY
interpret the false boolean object as a logical false, and any other object (including the true boolean object) as a logical true.
.Pp
A boolean is immutable and self-evaluating.
.Ss Symbols
The symbol data type contains objects holding an interned string of characters.
Symbol objects have identifiers as external representations.
Two symbol objects with the same external representation (either read or printed) are the same object
(they denote the same location in memory).
.Pp
Symbol objects (or "symbols" for short) are used to represent identifiers in programs.
The printed external representation of a symbol is called the
.Em name
of the symbol.
.Pp
A symbol is immutable and evaluates to the value bound to the variable with the same name as the symbol in the current environment.
.Ss End-of-file
The end-of-file data type contains a single object, called the end-of-file.
The end-of-file object has no read external representation.
It has, however, the printed external representation "#<eof>".
.Pp
The end-of-file object (or "eof" for short) is used to represent the end of a read file or program.
.Pp
The eof is immutable and self-evaluating.
.Ss Port
The port data type contains objects representing input and output devices.
A port object has no read external representation.
The printed external representation of a port is unique for a port object, but unpredictable.
.Pp
Port objects (or "ports", for short) can be input ports, used to read bytes from files or bytevectors;
or output ports, used to write bytes into files or bytevectors.
Ports can be closed.
When a port is closed, no further input/output operation is permited on that port.
Input/output operation can be buffered, and closing a port flushes the buffer.
.Pp
A port is immutable and self-evaluating.
.Ss Byte
The byte data type (also known as "character" data type)
contains a value from 0 to 255 inclusive.
The external representation of a byte is a character literal.
.Ss Bytevectors
The bytevector data type (also known as "string" data type)
contains objects denoting a sequence of zero or more locations in memory,
each one holding exactly a byte.
Where a
.Em byte
is an exact integer in the range from 0 to 255 inclusive.
A bytevector is typically more space-efficient than a vector containing the same values.
The external representation of bytevectors is a string literal.
.Pp
Bytevector objects are homogenous structures whose elements are indexed by integers and whose elements can be randomly accessed in constant time.
The
.Em length
of a bytevector is the number of elements that it contains.
This number is a non-negative integer that is fixed when the bytevector is created.
The
.Em valid indexes
of a bytevector are the exact non-negative integers less than the length of the bytevector,
starting at index zero.
.Pp
Bytevectors are usually used to hold string of characters encoded in UTF-8.
For example, "Hello World" and "Eĥoŝanĝo Ĉiuĵaŭde" are two strings of characters encoded in UTF-8 in a bytevector.
"\ex00\ex0A\ex05" is a bytevector of length 3 containing, in order, the bytes 0, 10 and 5 (or 0, A, and 5, in their hexadecimal form).
.Pp
A bytevector can be mutable or immutable, and is self-evaluating.
.Ss Vectors
The vector data type contains objects denoting a sequence of zero or more locations in memory,
each one holding an object of arbitrary type.
A vector object can have several different external representations (see below).
.Pp
Vector objects (or "vectors" for short) are heterogenous structures whose elements are indexed by integers and whose elements can be randomly accessed in constant time.
The
.Em length
of a vector is the number of elements that it contains.
This number is a non-negative integer that is fixed when the vector is created.
The
.Em valid indexes
of a vector are the exact non-negative integers less than the length of the vector.
The first element in a vector is indexed by zero, and the last element is indexed by one less than the length of the vector.
A vector can contain any object as its elements, even other vectors.
.Pp
A vector with zero element is called a
.Em nil .
A vector with one element is called a
.Em box .
A vector with two elements is called a
.Em pair .
A vector with a number n of elements is called a
.Em n-tuple .
.Pp
More complex data structures,
such as linked lists, hash tables, trees, and records (to name a few),
can be implemented in terms of vectors.
.Sh FORMAL SYNTAX
This section provides a formal syntax for
.Nm
written in an extended Backus-Naur form (BNF).
Nonterminals are written between angle braces
.Pq Ic "<...>" .
A terminal symbol is written between double quotation marks
.Pq Ic "\(dq...\(dq" .
.Pp
The following extensions to BNF are used to make the description more consise:
.Bl -bullet
.It
.Ic "<thing>*"
means zero or more occurrences of
.Ic "<thing>" .
.It
.Ic "<thing>+"
means one or more occurrences of
.Ic "<thing>" .
.It
.Ic "<thing>?\)"
means zero or one occurrence of
.Ic "<thing>" .
.El
.Pp
The BNF is augmented with the concepts of character classes and character ranges.
A
.Em character class
is expressed between square braces and colons
.Pq Ic "[:...:]"
and denotes a named set of characters.
A
.Em character range
is a set of characters and/or character classes between square braces
.Pq Ic "[...]"
and denotes any character in the set or in the classes.
For example,
.Pq Ic "[abc[:delimiter:]]"
means an
.Ic "a" ,
or
.Ic "b" ,
or
.Ic "c"
character, or a character in the
.Ic "[:delimiter:]"
class.
The notion of character range is augmented as follows.
.Bl -bullet
.It
The
.Ic "-"
character has the same special meaning in a character range it has in ERE.
For example,
.Ic "[0-9]"
is the same as
.Ic "[0123456789]"
(which is the same as
.Ic "[:decimal:]" ) .
.It
The
.Ic "^"
character has the same special meaning in a character range it has in ERE.
For example,
.Ic "[^abc]"
means any character but
.Ic "a" ,
.Ic "b" ,
or
.Ic "c" .
.It
The opening bracket
.Ic "\)["
may occur anywhere in a character range.
.It
The closing bracket
.Ic "\)]"
may occur only as the first character in a character range
.El
.Pp
Unprintable and hard-to-type characters are represented in the same escape notation used in string literals.
For example,
.Ic "\en"
is the newline.
.Ss Alphabet
The alphabet for this grammar is all the 256 bytes that can be read from a file augmented with the end-of-file indicator.
.Pp
The character classes are defined as follows.
.Bd -literal -offset indent
[:space:]         ← [ \ef\en\er\et\ev]
[:binary:]        ← [0-1]
[:octal:]         ← [0-7]
[:decimal:]       ← [0-9]
[:hexadecimal:]   ← [0-9A-Fa-f]
[:delimiter:]     ← [][()#[:eof:][:space:]]
.Ed
.Pp
The end-of-file indicator, in special, is represented by the special class
.Ic "[:eof:]" .
.Pp
The backslash character
.Pq Ic "\e" ,
the double-quote character
.Pq Ic "\(dq" ,
and the single-quote character
.Pq Ic "'" ,
which have special meanings and thus would need to be escaped,
are represented by the special classes
.Ic "[:slash:]" ,
.Ic "[:double-quote:]" ,
and
.Ic "[:single-quote:]" ,
respectively.
.Pp
The special character class
.Ic "[:anything:]"
represents any character in the alphabet.
.Ss Tokens
A
.Sy token
is the lexical element used to compose well formed expressions.
Some characters, known as
.Sy delimiters ,
have special meaning during the program parsing,
because certain tokens require a delimiter to occur after them.
A token is defined as follows:
.Bd -literal -offset indent
<token>           ← <end-of-file>
                  | <left-paren>
                  | <right-paren>
                  | <identifier>
                  | <char-literal>
                  | <string-literal>
                  | <number-literal>
.Ed
.Pp
The end-of-file is the token that terminates a program.
It is actually not a character, but is interpreted as if it were.
.Bd -literal -offset indent
<end-of-file>     ← [:eof:]
.Ed
.Pp
Single-character tokens are the following:
.Bd -literal -offset indent
<left-paren>      ← "("
<right-paren>     ← ")"
.Ed
A character literal is composed by one character element between single quotes.
A string literal is composed by zero or more character elements between double quotes.
A character element is any character other than a double quote or a backslash
or an escaped character.
Chracter literals and string literals are used to represent
characters and strings (alsow known as bytevectors) respectively.
The single and the double quotation mark characters that terminates a
character and a string are themselves delimiters.
.Bd -literal -offset indent
<char-literal>    ← [:single-quote:] <string-element> [:single-quote:]
<string-literal>  ← [:double-quote:] <string-element>* [:double-quote:]
<string-element>  ← [^[:double-quote:][:slash:]]
                  | [:slash:][:anything:]
.Ed
.Pp
A number literal begins with an optional signal and is followed by the number body.
A delimiter must occur after a numer literal.
.Bd -literal -offset indent
<number-literal>  ← <signal> <number-body>
<signal>          ← [+-]?
<number-body>     ← <binary-literal>
                  | <octal-literal>
                  | <decimal-literal>
                  | <hex-literal>
                  | <real-literal>
<binary-literal>  ← 0 [bB] [[:binary:]]*
<octal-literal>   ← 0 [oO] [[:octal:]]*
<decimal-literal> ← 0 [dD] [[:decimal:]]*
<hex-literal>     ← 0 [dD] [[:hexadecimal:]]*
<real-literal>    ← [[:decimal:]]+ <fraction>? <exponent>?
<fraction>        ← "." [[:decimal:]]*
<exponent>        ← <signal> [[:decimal:]]*
.Ed
.Pp
An identifier is any sequence of non-delimiter characters
that does not form another type of token.
A delimiter character must occur after an identifier.
.Bd -literal -offset indent
<identifier>      ← <initial> [^[:delimiter:]]*
<initial>         ← "+" [^[:decimal:][:delimiter:]]
                  | "-" [^[:decimal:][:delimiter:]]
                  | [^+-.[:decimal:][:delimiter:]]
.Ed
.Ss Escape sequences
Within a string literal, sequences of characters beginning with a backslash
.Pq Ic "\e"
are called
.Sy "escape sequences"
and represent bytes other than the characters themselves.
Most escape sequences represent a single byte,
but some forms may represent more than one byte.
An invalid escape sequence is equivalent to the character after the backslash;
for example, the string literal
.Dq Ic "\ej"
does not contain a valid escape sequence, so it is equivalent to
.Dq Ic "j" .
The valid escape sequences are as follows:
.Bl -tag -width Ds -compact
.It Ic \ea
Alarm (U+0007).
.It Ic \eb
Backspace (U+0008).
.It Ic \et
Horizontal tab (U+0009).
.It Ic \en
Line feed (U+000A).
.It Ic \ev
Vertical tab (U+000B).
.It Ic \ef
Form feed (U+000C).
.It Ic \er
Carriage return (U+000D).
.It Ic \ee
Escape character (U+001B).
.It Ic \e"
Double quote (U+0022).
.It Ic \e\e
Backslash (U+005C).
.It Ic "\e" Ns Ar num
Byte whose value is the 1-, 2-, or 3-digit octal number
.Ar num .
.It Ic "\ex" Ns Ar num
Byte whose value is the 1- or 2-digit hexadecimal number
.Ar num .
.It Ic "\eu" Ns Ar num
Bytes encoding, in UTF-8, the 4-digit hexadecimal number
.Ar num .
.It Ic "\eU" Ns Ar num
Bytes encoding, in UTF-8, the 8-digit hexadecimal number
.Ar num .
.El
.Ss Intertoken space
Tokens are separated by intertoken space, which includes both whitespace and comments.
Intertoken space is used for improved readability,
and as necessary to separate tokens from each other.
.Bd -literal -offset indent
<whitespace>      ← [[:space:]]
<comment>         ← "#" [^\en]* "\en"
<atmosphere>      ← <whitespace> | <comment>
<intertoken>      ← <atmosphere>*
.Ed
Whitespace can occur between any two tokens, but not within a token.
Whitespace occurring inside a string literal is significant.
.Pp
Comments are annotations in the source code and are treated exactly like whitespace.
A hash character
.Pq Ic "#"
outside a string literal indicates the start of a comment.
The comment continues to the end of the line on which the hash character appears.
.Ss Read external representation
The following is a simplification of the syntax of a read external representation.
This syntax is not complete, because intertoken-space may occur on either side of any token
(but not within a token).
.Bd -literal -offset indent
<representation>  ← <number>
                  | <string>
                  | <symbol>
                  | <vector>
<number>          ← <number-literal>
<byte>            ← <char-literal>
<string>          ← <string-literal>
<symbol>          ← <identifier>
<vector>          ← <left-paren> <representation>* <right-paren>
.Ed
.Ss Program
A
.Nm
program is a sequence of characters forming whitespace, comments, and tokens.
The tokens in a program must form syntactically well formed expressions.
.Bd -literal -offset indent
<program>         ← <expression>*
<expression>      ← <variable>
                  | <literal>
                  | <application>
<variable>        ← <symbol>
<literal>         ← <number> | <string>
<application>     ← <vector>
.Ed
.Sh FORMAL SEMANTICS
I have no idea what a formal semantics is or does.
.Sh EXAMPLES
[TODO]
.Sh SEE ALSO
.Xr simp 1 ,
.Xr simp 3
.Rs
.%A Harold Abelson
.%A Gerald Jay Sussman
.%A Julie Sussman
.%B Structure and Interpretation of Computer Programms
.%I The MIT Press
.%D 1996
.Re
.Sh STANDARDS
The
.Nm
programming language is compliant with nothing, as it has not been standardised.
It was influenced by the Scheme and Kernel LISP dialects.
.Pp
The syntax for comments and number literals breaks the usual LISP tradition,
and are influenced by shell script comments and C constants, respectively.
.Pp
Parts of this manual (especially at the
.Sx DESCRIPTION
section) were blatantly stolen from
.Rs
.%B Revised⁵ Report on the Algorithmic Language Scheme
.Re
.Sh HISTORY
The
.Nm
programming language was developed as a personal playground for
programming language theory, motivated by the reading of the Wizard Book
(Abelson & Sussman).  It first appeared as a C library in 2022.
.Sh AUTHORS
The
.Nm
programming language was designed by
.An Lucas de Sena Aq Mt "lucas AT seninha DOT org" .
.Sh BUGS
The
.Nm
programming language implemented in
.Xr simp 1
and
.Xr simp 3
is not complete, and may not conform to this manpage.
.Pp
This manual page is also not complete, as the language is only
informally specified, and may change significantly from one release to
the other.
.Pp
This manual uses the terms "string" and "bytevector" interchangeably,
as both refer to the same
.Nm
data structure.
Note that "string" and "string literal" refer to different concepts;
the former is a data type, while the latter is a token type.
.Pp
This manual avoids to use the word "character" to refer to the elements of a string.
This manual uses the word "character" to refer solely to the units that compose tokens read by the parser.
Strings in
.Nm
can possibly contain no valid character
(in the sense of a UTF-8 encoded codepoint).
This manual uses the term "byte" instead to refer to the elements of a string.
.Pp
There's no "character" data type,
either in the C sense of a "byte",
or in the sense of a UTF-8 encoded codepoint.
A single byte can be represented as a one-element string.
A UTF-8 encoded codepoint can be represented as a string containing the encoding bytes.
